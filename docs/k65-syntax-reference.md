# K65 Syntax Reference (Legacy-Accurate)

This reference is aligned to the legacy documentation snapshots in this repo:

- `docs/legacy/syntax.md`
- `docs/legacy/instructions.md`
- `docs/legacy/examples.md`

Where needed, behavior is cross-checked with the reference compiler grammar in `vendor/src/compiler.inc`.

## Core Language Constructs

### Comments

K65 uses C-style comments:

- `// line comment`
- `/* block comment */`

### Variables

Variables are symbolic names bound to memory addresses.

- `var foo=0x80`
- `var foo2` (auto-next address)
- `var foo3, foo4`
- `var bar[10]` (size advances address by array length)
- `var bar3 ?` (verbose declaration output)

### Constants

Legacy docs describe constants primarily via evaluator expressions (`[ ... ]`), e.g.:

```k65
[
  MY_CONSTANT = 5,
  SOME_NUMBER = 0x13
]
```

### Labels

- Global labels: `label:`
- Local labels: `.label:`

Local labels are used heavily in function-local flow patterns.

### Bank Selection

Legacy K65 uses `bank <name>` to select output bank.

```k65
bank my_bank
```

k816 compatibility note: `segment` is preferred in this codebase; `bank` is accepted as a deprecated alias.

### Data Blocks

Named data blocks define a label at block start and support:

- raw bytes / string data
- placement controls: `align`, `nocross`, `address`
- `code { ... }` embedded code emission
- `image ...` and `binary ...` generators
- `for x=a..b eval [ ... ]` generated bytes
- `charset "..."`

### Code Sections

Legacy docs define these section kinds:

- `main { ... }` (entry)
- `func name { ... }` (auto `RTS`)
- `naked name { ... }` (no auto `RTS`)
- `inline name { ... }` (inlined macro-like block)

### `else` Behavior

`else` lowers to an extra jump around the else block in generated branch flow.

### Far Calls

Legacy docs use `far <function>` for cross-bank function calls, with bankswitching handled by linker logic.

## One-Letter / Symbolic Operator Syntax

The legacy `instructions.md` page maps one-letter syntax to 6502 mnemonics.

### Loads, Stores, Transfers

- `a=imm`, `a=mem`, `a=mem,x`, `a=mem,y`, `a=(mem,x)`, `a=(mem),y` -> LDA
- `x=imm`, `x=mem`, `x=mem,y` -> LDX
- `y=imm`, `y=mem`, `y=mem,x` -> LDY
- `mem=a`, `mem,x=a`, `mem,y=a`, `(mem,x)=a`, `(mem),y=a` -> STA
- `mem=x` -> STX
- `mem=y` -> STY
- `x=a` -> TAX
- `y=a` -> TAY
- `x=s` -> TSX
- `a=x` -> TXA
- `s=x` -> TXS
- `a=y` -> TYA

### Arithmetic / Logic / Compare

- `a+...` -> ADC
- `a-...` -> SBC
- `a&...` -> AND
- `a|...` -> ORA
- `a^...` -> EOR
- `a?...` -> CMP
- `a&?...` -> BIT
- `x?...` -> CPX
- `y?...` -> CPY

### Increment / Decrement / Shift / Rotate

- `mem++`, `mem,x++` -> INC
- `mem--`, `mem,x--` -> DEC
- `x++`, `x--`, `y++`, `y--` -> INX/DEX/INY/DEY
- `a<<`, `mem<<`, `mem,x<<` -> ASL
- `a>>`, `mem>>`, `mem,x>>` -> LSR
- `a<<<`, `mem<<<`, `mem,x<<<` -> ROL
- `a>>>`, `mem>>>`, `mem,x>>>` -> ROR

### Flags and Stack

- `c+` / `c-` -> SEC / CLC
- `d+` / `d-` -> SED / CLD
- `i+` / `i-` -> SEI / CLI
- `o-` -> CLV
- `a!!` / `a??` -> PHA / PLA
- `flag!!` / `flag??` -> PHP / PLP (legacy docs use generic `flag`; practical forms include `z`, `c`, `n`, `v`, `b`, `i`, `d`)

### Flow and Branch Shorthands

- `goto label` -> JMP
- `goto (addr)` -> JMP indirect
- `call label` -> JSR
- `return` -> RTS
- `return_i` -> RTI

Branch operator forms:

- Prefix block: `OP { ... }`
- Goto: `OP goto label`
- Postfix block: `{ ... } OP`

Branch mapping (legacy docs):

- `<` / `c-?` -> BCC
- `>=` / `c+?` -> BCS
- `==` / `z+?` -> BEQ
- `!=` / `z-?` -> BNE
- `<0` / `n+?` -> BMI
- `>=0` / `n-?` -> BPL
- `>>=` / `v-?` -> BVC
- `<<=` / `v+?` -> BVS

Note: some legacy examples/doc snippets omit `?` in `v` aliases; the reference grammar uses `v-?` / `v+?`.

Loop forms:

- `{ ... } always`
- `{ ... } never`

### NOP Shorthand

- `*` -> one NOP
- `*<number>` -> wait-cycle form (legacy docs describe cycle semantics)

## Additional Grammar-Level Constructs

The reference compiler grammar (`vendor/src/compiler.inc`) also includes constructs that are not emphasized in legacy docs pages, such as:

- top-level `const`
- preprocessor directives (`#if/#else/#elif/#endif`, `#error`, `#warn`)
- evaluator function declarations (`evalfunc`)
- additional image/data helper directives

These can exist in sources, but the sections above reflect the legacy docs naming and operator semantics first.
